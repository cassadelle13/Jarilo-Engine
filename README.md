# Jarilo Ecosystem

Jarilo — это мультиагентная платформа с FastAPI-ядром, LLM-планировщиком и контейнеризированными исполнителями. Этот репозиторий объединяет
- Brain (координатор),
- агенты (Python/Node в Docker),
- плагины и документацию, позволяя запускать задачи, наблюдать их выполнение в реальном времени и расширять систему новыми инструментами.

## Архитектура в двух словах
1. **Brain** (`brain/`): FastAPI + LangChain + TinyDB; отвечает за REST/SSE интерфейсы, состояние задач, планирование и оркестрацию команд через `planner.py` и `executor.py`. Используются архитектурные паттерны DI, Strategy, Observer и Adapter (@JARILO_SYSTEMS.md#8-94). Коммуникация с агентами происходит по HTTP, LLM-интеграция выполняется через `planner` (OpenAI/подобные модели).
2. **Агенты** (`agents/*`, `agent/`): контейнеры, парсящие Markdown-ответы (mistune), извлекающие код и запускающие инструменты (bash/python). Каждый агент запускается в изолированном `workspace`, выводы логируются, метаданные возвращаются в Brain через HTTP.
3. **Streaming** (`STREAMING_ARCHITECTURE.md`): `EventDispatcher` публикует SSE-форматы (`PLAN_GENERATED`, `STEP_STARTED`, `TASK_COMPLETED` и другие) через `/api/v1/tasks/{task_id}/stream`. Контролируется heartbeats, таймауты и очистка очередей.
4. **Plugins/Test Suite** (`plugins/`, `tests/`): дополнительные инструменты (vite/data-analyst) и множество тестов `test_*` демонстрируют интеграционные сценарии, работу инструментов и потоков событий.

## Для чего использовать
- **Автоматизация рабочего процесса**: преобразуй промпты в пошаговые планы и выполняй их через агенты.
- **Наблюдаемость**: SSE потоки позволяют следить за жизненным циклом задач в режиме реального времени.
- **Исследования**: легко подменять LLM, добавлять плагины и эксперименты с планированием/исполнением.

## Быстрый старт
1. **Переменные**: создай `.env` рядом с проектом (см. `.gitignore`, туда нельзя пушить). Храни секреты локально.
2. **Зависимости**: `pip install -r brain/requirements.txt` и `npm install` в `plugins/vite_plugin` (если нужен фронтенд).
3. **Сервера**: `docker-compose up --build` поднимает brain, агентов и зависимые сервисы.
4. **Задачи**: `POST /api/v1/tasks/` (Brain) запускает план, `GET /api/v1/tasks/{id}/stream` подключается к SSE. `test_streaming.py` демонстрирует скрипт с реальными событиями.
5. **Очистка**: папки `workspaces/<uuid>/` удаляются после выполнения, но ты можешь вручную удалить лишние (например, пустые папки внутри `workspaces/`).

## Поддержка и развитие
- `.gitignore` уже исключает `.env`, логи, базы (`jarilo*.db`), `workspaces/*` (кроме `/test_data/`), Node/Docker артефакты и временные файлы. Добавляй новые правила по мере появления временных директорий.
- Удалённые файлы (например, `AUDIT_*`, `sales.csv`, `research_notes.txt`, `architecture_decision.txt`) выводят систему в состояние без конфиденциальных материалов. Используй `git rm` + `git commit` + `git push` для синхронизации.
- Документы в корне (`AUDIT_FINDINGS.md`, `AUDIT_REPORT.md`, `STREAMING_ARCHITECTURE.md`, `JARILO_SYSTEMS.md`) дают подробную картину компонентов и проблем безопасности/потоков.

## Как добавлять изменения
1. Делай `git add <paths>` после проверки `git status`.
2. Коммит с описанием: `git commit -m "feat: ..."`.
3. `git push` — всегда проверяй, что `.env` и другие игнорируемые файлы не попали в коммит.
4. Добавляй тесты (в `tests/` или через `test_*`-скрипты) при расширении логики Brain/агентов.
