# Architecture Decision: Error Handling in Jarilo

## Problem Statement
Current error handling in Jarilo is inconsistent and fragile. The Watcher pattern uses return tuples (plan, error), which is non-standard and error-prone. We need a robust, industrial-strength error handling mechanism.

## Research Summary
- **Open-Interpreter**: Swallows errors, logs and continues, returns error messages
- **MemGPT**: Raises custom exceptions from business logic, handles at layers with middleware
- **FastAPI**: Raises HTTPException for API errors, framework handles uncaught exceptions with JSON 500 responses

## Recommended Approach
Combine the best of both worlds:
1. **Raise exceptions from business logic** (like MemGPT) - cleaner than return tuples
2. **Framework-level exception handling** (like FastAPI) - centralized, automatic JSON responses

## Implementation Strategy
- Replace Watcher return tuples with proper exception raising
- Add global exception handler in FastAPI app for uncaught exceptions
- Use custom exception classes for different error types
- Ensure all exceptions result in proper HTTP responses

## Benefits
- Cleaner code (no tuple unpacking)
- Consistent error responses
- Better debugging with stack traces
- Framework handles edge cases automatically