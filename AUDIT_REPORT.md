# AUDIT_REPORT.md - Исчерпывающий аудит jarilo-ecosystem

## Обзор
Проведен полный аудит репозитория jarilo-ecosystem согласно чек-листу. Выявлены системные проблемы, блокирующие стабильную работу. Аудит проведен поэтапно от окружения к логике приложения.

## Уровень 1: Окружение и Сборка

### Аудит Зависимостей (requirements.txt)
**Проблемы:**
- **Отсутствие фиксации версий**: Все зависимости указаны без версий (например, `fastapi`, `pydantic`, `langchain`). Это приводит к нестабильным сборкам и потенциальным конфликтам между версиями.
- **Риск конфликтов**: `pydantic` без версии может установить v2, но некоторые библиотеки могут требовать v1.
- **Избыточность**: `httpx` указан отдельно, хотя `langserve[all]` может его включать.

**План исправления:**
1. Зафиксировать версии ключевых библиотек:
   - `fastapi==0.104.1`
   - `pydantic==2.5.0` (или `pydantic==1.10.13` если конфликты)
   - `langchain==0.1.0`
   - `langgraph==0.0.40`
   - `openai==1.3.0`
2. Удалить дубликаты (`httpx` если уже в langserve).
3. Добавить `pip-tools` для управления зависимостями.

### Аудит docker-compose.yml
**Проблемы:**
- **Отсутствие явной сети**: Сервисы `brain` и `agent` не в одной сети, что может вызвать проблемы с DNS.
- **Переменные окружения**: `HOST_WORKSPACE_ROOT` использует `${PWD}`, что может не работать в контейнере.
- **Тома**: Монтирование `/var/run/docker.sock` дает полный доступ к Docker хосту (безопасность).

**План исправления:**
1. Добавить сеть:
   ```yaml
   networks:
     jarilo-net:
       driver: bridge
   services:
     brain:
       networks:
         - jarilo-net
     agent:
       networks:
         - jarilo-net
   ```
2. Исправить `HOST_WORKSPACE_ROOT` на фиксированный путь или переменную.
3. Рассмотреть ограничение прав на docker.sock или альтернативные решения.

### Аудит Dockerfile
**Проблемы:**
- **Кэширование**: `COPY src/ .` после установки зависимостей - изменения в коде инвалидируют кэш зависимостей.
- **Пользователь**: Запуск от root - потенциальная уязвимость.
- **Рабочая директория**: WORKDIR /app, но приложение запускается из src/.

**План исправления:**
1. Переместить `COPY src/ .` перед установкой зависимостей для лучшего кэширования.
2. Добавить пользователя:
   ```dockerfile
   RUN useradd --create-home --shell /bin/bash app
   USER app
   ```
3. Установить WORKDIR /app/src если приложение там.

## Уровень 2: Конфигурация и Инициализация Приложения

### Точка Входа (main.py)
**Проблемы:**
- **Порядок инициализации**: ToolRegistry и compiled_graph не инициализируются в lifespan - возможны ошибки при первом запросе.
- **Обработка ошибок**: Есть базовый обработчик, но не покрывает все случаи.

**План исправления:**
1. Добавить инициализацию в lifespan:
   ```python
   @asynccontextmanager
   async def lifespan(app: FastAPI):
       # Инициализация БД
       await db_manager.init_db()
       # Инициализация ToolRegistry
       from tools.registry import tool_registry
       await tool_registry.initialize()
       # Инициализация графа
       from orchestration import compiled_graph
       yield
   ```

### Зависимости (api/dependencies.py)
**Проблемы:**
- **Жизненный цикл**: `state_manager` и `compiled_graph` инициализируются на уровне модуля - могут вызвать проблемы при импорте.
- **Асинхронность**: Нет явных проверок на асинхронность зависимостей.

**План исправления:**
1. Переместить инициализацию в lifespan main.py.
2. Добавить проверки на асинхронные операции в зависимостях.

## Уровень 3: Логика Ядра

### Аудит Графа (graph.py)
**Проблемы:**
- **Условия завершения**: В `should_continue` логика сложная, возможны бесконечные циклы если `replan_attempts` не увеличивается.
- **Обработка исключений**: В `executor_node` есть базовый try/except, но не покрывает все случаи (например, исключения в tool_registry).
- **OpenAI зависимость**: Несмотря на изменения, planner_node все еще пытается использовать OpenAI API.

**План исправления:**
1. Улучшить `should_continue`:
   ```python
   if replan_attempts >= 3:
       return END
   if "good" in critique and not plan:
       return "reflection_node"
   # ...
   ```
2. Добавить детальную обработку в executor_node.
3. Полностью отключить OpenAI в planner_node для тестирования.

### Аудит Инструментов (tools/)
**Проблемы:**
- **Блокирующие вызовы**: PluginSandbox использует `asyncio.get_event_loop().run_in_executor`, что хорошо, но exec_run с stream=True требует асинхронной обработки.
- **Обработка stdout/stderr**: В execute методе используется демультиплексирование, но генератор exec_result.output может блокироваться.

**План исправления:**
1. Исправить execute в PluginSandbox:
   ```python
   async def execute(self, command: str):
       # Использовать asyncio.create_subprocess_shell для полной асинхронности
   ```
2. Улучшить сборку вывода в PluginTool.

## Критические Проблемы
1. **Таймауты**: Вероятно вызваны синхронными вызовами в асинхронном коде (docker-py без run_in_executor).
2. **Инициализация**: Отсутствие правильной инициализации компонентов при старте.
3. **Зависимости**: Нестабильные версии приводят к конфликтам.

## План Действий
1. Исправить зависимости и зафиксировать версии.
2. Перестроить Dockerfile с правильным кэшированием и пользователем.
3. Добавить сеть в docker-compose.
4. Переместить инициализацию в lifespan.
5. Исправить асинхронность в tools.
6. Протестировать все компоненты по отдельности.

## Ожидаемый Результат
После применения исправлений тесты `test_self_correction.py` и `test_vite_plugin.py` должны проходить стабильно без таймаутов.