# Research Notes: Error Handling Patterns in Open-Source Projects

## Open-Interpreter
- **Location**: source-code/open-interpreter/
- **Error Handling Approach**: 
  - Uses try-except blocks extensively in core execution logic
  - Often catches exceptions and logs them, then continues or returns error messages
  - Example: In interpreter.py, exceptions during code execution are caught and handled gracefully
  - Pattern: Catch, log, and return structured error responses rather than raising

## Tool Research: MemGPT and Open-Interpreter Tools

### MemGPT Tools Analysis
- **Location**: source-code/memgpt/letta/functions/function_sets/
- **Findings**: 
  - files.py: Contains async function signatures for file operations (read_file, write_file, etc.) but all raise NotImplementedError
  - builtin.py: Contains run_code functions, also not implemented
  - No actual working tool implementations found in MemGPT codebase
  - Functions appear to be placeholders/interfaces rather than working implementations

### Open-Interpreter Tools Analysis  
- **Location**: source-code/open-interpreter/interpreter/computer_use/tools/
- **Key Files**:
  - edit.py: Contains working read_file() and write_file() implementations
  - bash.py: Bash shell execution tool
  - run.py: Utility for running shell commands
  - base.py: Base classes for tool architecture
- **Architecture**: Tools inherit from BaseAnthropicTool, use async execution
- **Recommendation**: Use Open-Interpreter tools as the foundation for Jarilo's tool system, as MemGPT tools are not implemented

## MemGPT
- **Location**: source-code/memgpt/
- **Error Handling Approach**:
  - Implements custom exception classes (e.g., in errors.py)
  - Uses try-except with specific exception types
  - Often raises custom exceptions from business logic
  - Higher-level code catches and handles appropriately
  - Pattern: Raise specific exceptions, catch at appropriate levels

## FastAPI
- **Location**: source-code/fastapi/docs/tutorial/handling-errors/
- **Error Handling Approach**:
  - Use HTTPException for API errors (raises exceptions with status codes)
  - Global exception handlers via @app.exception_handler() for custom exceptions
  - Unhandled exceptions automatically return 500 with JSON response
  - Can override default handlers for RequestValidationError, HTTPException
  - Pattern: Raise HTTPException from business logic, framework handles uncaught exceptions

## Key Findings
- Open-Interpreter: Swallows errors, returns error messages
- MemGPT: Raises custom exceptions, handles at layers
- FastAPI: Framework handles uncaught exceptions, custom handlers for specific errors